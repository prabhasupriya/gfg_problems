void swap(int i, int j, char **s) {
    char * tmp = s[i];
    s[i] = s[j];
    s[j] = tmp;
}

int find_next_fix(int n, char **s) {
    // if we're here then s[1] to s[n-1] are sorted.
    // the next element to fix in position s[0] will be s[k]
    // such that s[k-1] <= s[0] < s[k]
    for(int k = 1; k < n; ++k) {
        if (strcmp(s[0], s[k]) < 0) {
            swap(0, k, s);
            return 1;
        }            
    }
    return 0;
}

void restore_sequence(int n, char **s) {
    // if we're here, then s is such that s[0] is the largest element 
    // and s[1] to s[n-1] are sorted from smallest to largest
    // all we need to do is move s[0] to the end
    for(int k = 1; k < n; ++k) {
        swap(k-1, k, s);
    }
}

int next_permutation(int n, char **s)
{
	/**
	* Complete this method
	* Return 0 when there is no next permutation and 1 otherwise
	* Modify array s to its next permutation
	*/

    // bottom of recursion
    if (n == 1) return 0;
    // keep s[0] fixed and construct the next permutation of s[1] to s[n-1]
    if (next_permutation(n-1, s+1)) return 1;
    // if there are no more permutations of s[1] to s[n-1], then find 
    // the next element to fix in s[0]. If successful, that will construct the first 
    // permutation of the new s[1] to s[n-1]
    if (find_next_fix(n, s)) return 1;
    // if there are no more s[0], then restore the sequence and return 0
    restore_sequence(n, s); 
    return 0;
}permutation
